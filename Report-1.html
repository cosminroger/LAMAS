<!DOCTYPE html>
<html>
    <head>
<link rel="stylesheet" href="style.css">
<!--cite sttyle sheet: comparto https://www.free-css.com/free-css-templates/page266/comparto--> 
    </head>
<body>
 
<h1 style="text-align:center">Blockchain simulation</h1>

<br>
<br>
<h2 style="text-align:center">Introduction</h2>

<br>
<br>
<center>
<p style="width: 70%;" align="justify" style="text-align:justify" >

Nowadays, we keep hearing of the term <b>blockchain</b> and <b>cryptocurrency</b>, and although the second term is, at least in concept, well known, the first is not fully 
understood by many people. In the present project, we will investigate how messages are sent among agents in a blockchain, attempt to falsify blockchain information, 
and show how these are getting rejected. We will provide a (simplified) blockchain model with the intent of graphically demonstrating all the perks of sending 
information through a blockchain. 
Our research question essentially amounts to:
<br>
<b>How does communication between agents work in a blockchain? What happens when not all agents are truthful? How are the messages verified?</b>
We will attempt to answer all of these questions by implementing our blockchain model, testing it, and reporting the results.
<br>
<br>
Essentially all cryptocurrency relies on the blockchain. Cryptocurrency at its core is a method of maintaining a <b>decentralised currency</b>not dependent on a 
central authority such as a particular government or bank, as is the case of classical currency. But then who keeps track of all the transactions that occur and 
all the sums that everyone has instead of a central bank or authority? The answer is everybody! A blockchain is a computer system that stores and shares a common 
database among all other computers (or participants/agents that are part of that blockchain). Essentially the blockchain can crowdsource all the checks and balances
 usually performed by a central agency. So how does that work? Do the agents have to trust each other? Fortunately, not necessary, using concepts from logic such as
<b>common knowledge and public announcements</b>, combined with communications protocols and specific algorithms, a blockchain is implemented that keeps track of 
everything and acts as a type of hive mind and impartial arbiter.

<br>
<br>
But what really is a blockchain, how does it work, and how does it implement epistemic logic in its functioning?

</p>

<h2 style="text-align:center">Blockchain: what it is and how it works</h2>

<br>
<br>

<p style="width: 70%;" align="justify" style="text-align:justify">
As mentioned, a blockchain is functionally a way to keep track of transactions. It has the function of being an impartial arbiter in deciding how money
is being transferred and how much each agent has. It essentially guarantees the currency and its trading is fair and all decisions made with respect to it are equitable.
<br>
<br>
The blockchain can, for starters, essentially be thought of as a giant ledger or database. Within this database, we would store all the information about all the trades 
that were ever made and the amount of money each agent has. However, unlike classic databases, the data is not simply structured in consecutive entries. Data is structured
in blocks, essentially a collection of multiple transactions or access in our hypothetical ledger. Each block is filled with several transactions and then added (along
with a timestamp) to a chain of such blocks (hence the name) that form an indelible, traceable trade history shared amongst all users. This represents the truth that 
all following blocks have to abide by.
<br>
<br>
So now we've seen how the blockchain is structured from an architectural standpoint and know how the data stored in it looks; let us discuss how this data is added and 
verified. Essentially this relies on the decentralization of the blockchain. Instead of keeping all the data in the blockchain in just one centralized location, everyone 
gets a copy of it. Every user has full access to the aforementioned trade history added to the blockchain since the respective user started using that particular cryptocurrency. 
So when a new transaction is to be added, it goes out to all (or a huge number of) users and compares with their local copy of the blockchain. Should a transaction not line 
up with this comprehensive history, a fraud attempt took place quickly. Even if multiple users collaborate on the fraud, most blockchains use majority voting (although other 
algorithms have been employed) to determine whether a transaction can be added or not to a block. As such, a fraudster would need to control most of the users in a network to 
perpetrate fraud. As opposed to a regular currency where all trust is placed in a central authority, all of the cryptocurrency users get to verify each transaction using the blockchain.
<br>
<br>
To understand how a blockchain works, let's consider the following example:
<br>
<br>
<i>Agent A</i> wants to send a message to <i>agent B</i>. 
Typically, one would send this message, relying on other entities to make sure that the message got sent. Namely, you rely on a third party. If the third party loses the message, 
or modifies it, it would not be a pleasant experience for the sender.
<br>
<br>
This is where blockchains come in. These are a growing sequence of blocks containing approved transactions alongside a cryptographic hash of the previous block, creating the 
blockchain. So, the new block made at step i will include index i, its content D, and the hash of the previous block i-1. Every agent stores this blockchain, and any update 
needs to be made to the entire sequence. You cannot change at step i-5, for instance, without changing the information in all blocks from i-4 to i. Given how big these blockchains 
and networks of agents are for some cryptocurrencies (like Ethereum and Bitcoin) and that every message (block) received is further verified by some algorithms to ensure its 
validity, it is nearly impossible to falsify the information. One would need to falsify all the blocks up to a point, as mentioned before. Still, it is also mandatory that 
at least 50%+1 agents from that network perform the same operations, hence why it would be impossible to falsify the same operations data contained in such a big blockchain.
<br>
<br>
So how does this relate to epistemic logic? As mentioned before, we are working mainly with the concepts of public announcement and common knowledge. Each copy of the 
blockchain that an agent has represents the indelible history against which an agent compares all new facts. Therefore the blockchain itself can be thought of as a representation 
of the common knowledge shared between agents. Specifically, the blockchain is the common knowledge shared between truthful agents. By comparison with this common knowledge, 
we can determine what is true or not, propositions compatible with common knowledge being considered authentic and added to the blockchain (and so the common knowledge of 
truthful agents). In contrast, requests that create contradictions are deemed false and rejected.
<br>
<br>
Every time an agent makes a transaction, this transaction is broadcast to other agents for verification. Therefore, this can be thought of like an announcement; just like 
in a classic epistemic logic announcement, the transaction is sent out as a proposition to all agents. The difference here is that instead of the announcement being considered 
inherently truthful and believed, this announcement is compared to the common knowledge held by other agents. Should this announcement be compatible with the common knowledge, 
the proposition within is added to the aforementioned common knowledge. Should the announcement be determined to be false, it will not be added to the common knowledge, and it 
will be identified as fraudulent.
<br>
<br>
This logic of announcements and common knowledge underpins the functioning of the blockchain and is what allows cryptocurrencies to function. This system can essentially be 
thought of as solving many logic exercises as various trades get added to the blockchain. For every transaction added in the form of a public announcement, the logic problem 
of <b>"can this exist given what we know, is the various agents quickly solve the formula valid given the common knowledge"</b>  in the system using their copy of the blockchain. 
Using this system, a decentralized currency can be created by simply implementing these concepts of epistemic logic.
     
</p>

<h2 style="text-align:center">Implementation: bringing the blockchain to life</h2>
<br>
<br>
<p style="width: 70%;" align="justify" style="text-align:justify">
    As inspiration for implementing epistemic logic for our blockchain, we have used the following articles:
    Brunnler Kai, Flumini, D., & Studer, T. (2020) <i>A logic of blockchain updates</i>. Journal of Logic and Computation, 30(8), 1469â€“1485. 
    In this article, an entirely new logic system is proposed, namely BCL, where dynamic logic is used to reason about blockchain updates and prove that BCL is sound and complete.
    As well as Halpern, Joseph & Pass, Rafael. (2017). <i>A Knowledge-Based Analysis of the Blockchain Protocol</i>. Electronic Proceedings in Theoretical Computer Science. 251. 324-335. 10.4204/EPTCS.251.22. 
    TThis paper analyses blockchain through the lenses of classical logic rather than proposing a new one. This latter paper ultimately served as the basis of our 
    implementation, although inspiration was also taken from <i>A logic of blockchain updates</i>.
    <br>
    <br>
    Our implementation was done in python, specifically as a python jupyter notebook. What we do in this implementation is simulate the functioning of a blockchain as 
    multiple transactions take place. Essentially, wherein a real blockchain, we would have several asynchronous users making trades; in our implementation, there will 
    be a single thread modeling all of the interactions that would typically occur and how various types of transactions would occur. This includes successful transactions 
    and (unsuccessful) attempts at fraudulent transactions to show how the blockchain ensures the validity of said transactions. To better understand the functioning of 
    our model, let us take a look at the various classes we have implemented and what each one does.
    <br>
    <br>
    <b>The Agent</b> class is essentially our actor, representing an agent with money and making a transaction. This agent can send and receive messages and check 
    whether a trade is acceptable. First of all, sending messages is how the agent initiates transactions or sends messages regarding transactions. The agent is not 
    guaranteed to succeed and has a random chance of failing to send a message, meaning a basic system of higher-order knowledge is used to ensure communication. Messages 
    are broadcast to all other agents that take part in the blockchain. Receiving messages is more complicated since they depend more on other agents. A message first 
    needs to be confirmed as still valid. As such, the timestamp of the message is first compared to the blockchain. If the message is found to be outdated, it is deleted. 
    Since the agent cannot control the rate at which messages come in, they are placed in a queue until the agent is ready to process them, processing the message in what 
    constitutes the trust base of the blockchain. The agent analyses the content of the message and compares it to their local copy of the blockchain. At this point, the 
    agent will check every transaction it knows that it took place and calculate whether enough funds are available for the transaction to be valid. If that is true, then 
    the message is marked as accurate; else, it is considered fraudulent. Transactions will also usually be received from two sources: the sender and the receiver. As such 
    higher-order knowledge is used again to check that the message from both sources matches and ensure the same transaction isn't processed twice.
    <br>
    <br>
    <b>The Block</b> class is, as the name suggests, the building block of the blockchain. A block represents essentially any transaction or message that gets added 
    to the blockchain. It is the elementary storage unit for data in our system and ultimately can record and store any actions taking place in the system. The block 
    can store data about a particular message or transaction. To that end, it contains a data field for storing the actual content of what it is registering and fields 
    for recording the agents' involved names of sender and receiver. These blocks will also need to be linked up into the blockchain eventually, and to accomplish this, 
    these two more features are required. Firstly, each block is numbered; this allows the system to keep track of the order of transactions and events; the numbering 
    of these blocks monotonously increases, with the first block in the blockchain being block 0. Secondly, each block has a unique hash value. This hash value expresses 
    the block's identity. It is made up using data from all other parameters of the current block plus the previous block's hash (which ensures traceability). Also 
    related to the block class is another class, the pendingBlock. This pendingBlock class essentially acts as an intermediary being used to store, as the name implies, 
    pending blocks either from the memory of various agents or in the queue to be added to the blockchain. The pendingBlock class is similar to a block in the type of 
    information it stores; it doesn't have a hash or number field, instead of being identified through a simple ID. Additionally, the pendingBlock class also has a 
    few extra features that facilitate checking and validating.
    <br>
    <br>
    <b>The BlockChain</b> class is perhaps the most important in our implementation, tying everything together and implementing the very backbone of our model. 
    The BlockChain class doubles as implementing the blockchain itself and acting as a sort of run function for our simulation, setting everything into motion. 
    The BlockChain we use is essentially a series of blocks, with several methods to ensure that all the blocks being added are valid and in the correct order. 
    Our BlockChain keeps track of agents (this is more related to its secondary function than necessarily an actual blockchain) and has a queue of pending blocks 
    that are to be checked and added.
    <br>
    <br>
    First, we will talk about the BlockChain class related to the functioning as the structure of actual blockchains. At the root of the BlockChain is known as a genesis block, 
    which has 0 in all fields. Every blockchain has such a block, and it represents the starting point of the chain. From here, new blocks are added to the chain; if they are 
    valid, of course, a sanity check is also performed at this stage. We implemented a threshold of 5 for the checks performed before adding or removing a block. If five different 
    agents agree that a particular block is correct, the respective block will be approved and added to the blockchain.
    <br>
    Conversely, if five agents agree that a block is fraudulently said block is deleted. This relatively low threshold provides slightly less protection than real-life 
    blockchains; however, it also dramatically increases performance, and as there is no way for the agent that initiates the transaction to know which agents will be 
    verifying it first (and therefore that it needs to manipulate) this is still a reasonably safe method. Finally, at every timestep, the validity of the blockchain is verified, 
    block hashes are inspected and validated.
    <br>
    <br>
    Second, we will talk about the BlockChain class related to the implementation and running of our simulation. As discussed previously, rather than model our simulation of a 
    blockchain using multiple asynchronous threads representing each agent, we have decided that to analyze how a blockchain function from the point of view of epistemic logic, 
    as well as to increase performance, we would implement a model running several transactions from various agents in a single thread. This thread is implemented within the 
    BlockChain class. First of all, the setup: our simulation considers 100 agents, each with 10000 coins. The creation of these agents also constitutes the first blocks added 
    to the blockchain after the genesis block; unlike blocks initiated by agents, these initial blocks do not need to be verified as we are sure they are valid. Then the actual 
    simulation is implemented as a stochastic process. First, at every step, two different random agents are selected, these agents will begin a transaction. A transaction, 
    however, will not always be successful or truthful. For every transaction, there is a chance that either the transaction will be invalid or that the sender and receiver 
    will disagree about its contents; these represent fraudulent messages which will be identified as such. There is also a chance that an announcement will fail for unknown 
    reasons; this is to model the inherent risk in any communication method essentially. After messages related to all transactions that occur during a timestep have been sent 
    out, they are analyzed and processed. First, the actual sending out of the messages happens, where these messages are sent to other agents. These messages are then placed 
    in a queue individually for each agent. Agents go through their respective queues and analyze the messages in them, either validating or invalidating them. All valid messages 
    are formed into blocks and added to the blockchain; then, agents are updated concerning this blockchain change. Finally, the blockchain checks that its integrity has not 
    been compromised, and the whole process repeats in the following timestep.


</p>

<h2 style="text-align:center">Conclusions and discussion</h2>

<br>
<br>
<p style="width: 70%;" align="justify" style="text-align:justify">

Overall the blockchain met our expectations and performed correctly. We ran a simulation consisting of 10 timesteps. The following parameters were used: a 10% chance for 
a message to be invalid due to an agent using more funds than they have, a 10% chance for the data to be invalid due to there being different messages from the sender and 
receiver, and a 30% chance that sending a message will fail due to message transmission-related reasons. We saw messages added successfully and blocks rejected by agents 
throughout our simulations based on them being found to be fraudulent. In short, the blockchain model works, both as a ledger for transactions and as an arbiter, ensuring 
that transactions are valid and fair.
<br>
<br>
As previously mentioned, cryptocurrencies in general and the blockchain are exciting real-world cutting edge applications of concepts found in epistemic logic. 
A blockchain can be thought of essentially as a system of accountability based on employing a group of perfect logicians. Every time someone does anything, they must make 
a public announcement, sharing the knowledge of what they have done with everyone. These perfect logicians then use their expertise of preexisting facts to decide whether 
that action is possible. Should there be contradictions, the action is determined to be a lie. These preexisting facts then form a common knowledge shared between all truthful 
agents, essentially the blockchain. This type of application of logic has allowed a significant change in the dynamics of economic systems across the planet. Using this new 
system, it is now possible to create a completely decentralised currency system, removed from any central governing authority and therefore does not require the trust of its 
users to be placed into a single ideological, political or economic body. Indeed it instead requires trusting that everyone else is mainly engaging in only serving their 
interests. Yet, through the implementation of this, ultimately robust and not overly complicated logic system of checking public announcements against a pool of common knowledge, 
these interests can be used to guarantee equitability and a trustworthy system for all.

</p>
</center>
</body>

</html>
