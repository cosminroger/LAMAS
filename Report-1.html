<!DOCTYPE html>
<html>
    <head>
<link rel="stylesheet" href="style.css">
<!--cite sttyle sheet: comparto https://www.free-css.com/free-css-templates/page266/comparto--> 
    </head>
<body>
 
<h1 style="text-align:center">Blockchain simulation</h1>

<br>
<br>
<h2 style="text-align:center">Introduction</h2>

<br>
<br>
<center>
<p style="width: 500px;" align="justify" style="text-align:justify" >

Nowadays, we keep hearing of the term <b>blockchain</b> and <b>cryptocurrency</b>, and although the second term is, at least in concept, well known, the first is not fully understood by many people. 
In the present project, we are going to investigate how messages are sent among agents in a blockchain, make attempts at falsifying blockchain information and show how these are getting rejected. 
We will provide a (simplified) blockchain model with the intent of graphically demonstrating all the perks of sending information through a blockchain.
Our research question essentially amounts to:
<br>
<b>How does communication between agents work in a blockchain? What happens when not all agents are truthful? How are the messages verified?</b>
 We will attempt to answer all of these questions by implementing our blockchain model, testing it and reporting the results.
<br>
<br>
Essentially all cryptocurrency relies on the blockchain. Cryptocurrency at its core is a method of mainting a <b>decentralised currency</b>, not dependent on a central authority such as a certain goverment or bank as is the case of classical currency.
But then who keeps track of all the transactions that take place and all the sums that everyone has in lieu of a cenbtral bank or authority ? The answer is everybody! 
A blockchain is a system of computers that store and share a common database among all other computers (or participants/agents that are part of that blockchain). Essentially the blockchain can be said to crowdsource all the checks and balances normally performed by a central agency.
So how does that work? Do the agents just have to trust each other? 
That is fortunately not necessary, using concepts from logic such as <b>common knowledge and public announcements</b>, combined with communications protocols and certain algorithms, a blockchain is implemented which keeps tracks of everything and acts as a type of hive mind and impartial arbiter.


<br>
<br>
But what really is a blockchain, how does it work, and how does it implement epistemic logic in its functioning?

</p>

<h2 style="text-align:center">Blockchain: what it is and how it works</h2>
<br>
<br>
<p style="width: 500px;" align="justify" style="text-align:justify">
    As mentioned, a blockchain is functioanlly a way to to keep track of transactions. It has the function of being an
     impartial arbiter in deciding how money is being transfered as well as how much each agent has. 
     It essentially guarantees the currency and its trading is fair and all decisions made with respect to it are equitable. 
     <br>
     <br>
     The blockchain can for starters essentially be thought of as a big ledger or database. Within this database we would store 
     all the information about all the trades that were ever made as well as the amount of money each agent has. However unlike classic 
     databases the data is not simply structured in consecutive entries. Data is structured in blocks, esentially a collection of multiple
     transactions or entries in our hypothetical ledger. Each block is filled with a number of transactions, and then added 
     (along with a timestamp) to a chain of such blocks (hence the name) that form an indelible, traceable trade history
      shared amongst all users. This represents the truth that all following blocks have to abide by.
      <br>
      <br>
      So now we've seen how the blockchain is structured from a architectural standpoint, and know how the data stored in it looks, let 
      us discuss how this data is added and verified. Essentially this relies on the decentralization of the blockchain, instead of storing
      all the data in the blockchain in just one centralised location everyone gets a copy of it. Every user has full acces to the aforementioned
      trade history that has been added in the blockchain since the respective user started using that particular cryptocurrency. So when 
      a new transaction is to be added, it goes out to all (or a very large number of) users and compared with their local copy of the 
      blockchain. Should a transaction not line up with this expansive history it can be quickly determined that a fraud attempt took place. 
      Even if multiple users colaborate on the fraud, most blockchains use majority voting (although other algorithms have been known to be 
      employed) to determine wether a transaction can be added or not to a block. As such a fraudster would need to control most of the users
      in a network to perpetuate a fraud. As opposed to a normal currency where all trust is placed in a central authority, all of the users
      of a cryptocurrency get to verify each transaction using the blockchain.
    <br>
    <br>
    In order to understand how a blockchain works let's consider the following example:
    <br>
    <br>
    <i>Agent A</i> wants to send a message to <i>agent B</i>. 
    Normally, one would send this message and it relies on other entities to make sure that the message got sent, namely, you rely on a third party. If the third party looses the message, or modifies it, it would not be a pleasant experience for the sender. 
    <br>
    <br>
    This is where blockchains come in. These are a growing sequence of blocks which contain approved transaction alongside with a cryptographic hash of the previous block, creating the blockchain. 
    So, the new block created at step i will contain an index i, its content D, and the hash of the previous block i-1. This blockchain is stored by every agent and any update needs to be made to the entire sequence. 
    You cannot make a change at a step i-5, for instance, without changing the information in all blocks from i-4 to i. 
    Given how big these blockchains and networks of agents are for some cryptocurrencies (like Ethereum and Bitcoin) and the fact that every message (block) received is further verified by some algorithms to ensure its validity, it is nearly impossible to falsify the information. 
    Not only that one would need to falsify all the blocks up to a point as mentioned before, but it is also mandatory that at least 50%+1 agents from that network to perform the same operations, hence why it would be impossible to falsify the data contained in such a big blockchain.
    <br>
    <br>
    So how does this relate to epistemic logic? Well as mentioned before we are working mainly with the concepts of 
    public announcement and common knowledge. Each copy of the blockchain that an agent has represents the indelible
    history against which an agent compares all new facts. Therefore the blockchain itself can be thought of as 
    a representation of the common knowledge shared between agents. Specifically the blockchain is the common knowledge
    shared between truthful agents. It is by comparisson with this common knowledge that we can determine what is true
    or not, propositions compatible with common knowledge being considered true and added to the block chain (and 
    so the common knowledge of truthful agents) while propositions that create contradictions are considered false
    and rejected. 
    <br>
    <br>
    Every time an agent makes a transaction, this transaction is broadcast to other agents for verification.
    This can therefore be thought of as an announcement. Just like in a classic epistemic logic announcement the transaction
    is sent out as a proposition to all agents. The difference here is that instead of the announcement being considered
    inherently truthful and believed, this announcement is actually compared to the common knowledge held by other agents.
    Should this announcement be compatible with the common knowledge, the proposition within is added to the aforementioned
    common knowledge. Should the announcement be determined to be false it will not be added to the common knowledge and
    it will be identified as a false.
    <br>
    <br>
    This logic of announcemetns and common knowledge underpins the functioning of the blockhcain and is what allows cyptocurrencies to 
    function. This system can essentially be though of as solving many logic exercises as various trades get added to the blockchain. For
    every trade added in the form of a public announcement the logic problem of <b>"can this exist given what we know, is the formula
        valid given the common knowledge"</b>  is quickly solved by the various agents in the system ysing their copy of the blockchain.
        Using this system a decentralised currency can be created by simply implementing these concepts of epistemic logic.
     
</p>

<h2 style="text-align:center">Implementation: bringing the blockchain to life</h2>
<br>
<br>
<p style="width: 500px;" align="justify" style="text-align:justify">
    As inspiration for the implementation of epistemic logic for our blockchain, we are used the following articles: 
    Brunnler Kai, Flumini, D., & Studer, T. (2020) <i>A logic of blockchain updates</i>. Journal of Logic and Computation, 30(8), 1469â€“1485. 
    In this article an entirely new logic system is proposed, namely BCL, where dynamic logic is used to reason about blockchain updates, and finally, prove that BCL is sound and complete.
    As well as Halpern, Joseph & Pass, Rafael. (2017). <i>A Knowledge-Based Analysis of the Blockchain Protocol</i>. Electronic Proceedings in Theoretical Computer Science. 251. 324-335. 10.4204/EPTCS.251.22. 
    This paper analyses blockchain through the lenses of classical logic rather than proposing a new one. It was ultimately this latter
    paper that served as the basis of our implementation, although inspiration was also taken from <i>A logic of blockchain updates</i>.
    <br>
    <br>
    Our implemetation was done in python, specifically as a python jupyter notebook. What we do in this implementation is simulate the 
    functioning of a blockchain as multiple transactions take place. Esentially, where in a real blockhain we would have several asynchronous
    users doing trades, in our implementation there will be a single thread modelling all of the interactions that would normally take place
    and how various types of transactions would take place. This includes not only succesful transactions but also (unsuccesful) attempts
    at fraudulent transactions to show the manner in which the blockchain ensures the validity of said transactions.In order to better
    understand the functioning of our model, let us take a look at the various classes we have implemented and what each one does.
    <br>
    <br>
    <b>The Agent</b> class is essentially our actor. Representing an agent who has an amount of money and makes transaction, this agent is
    capable of sending and receiving messages as well as checking wether a transaction is acceptable. First of all to send messages,
    this is the manner in which the agent initiates transactions or sends messages regarding transactions. The agent is not guaranteed
    to succed and has a random chance of failing to send a message, meaning a basic system of higher order knowledge is used to ensure
    communication. Messages are broadcast to all other agents that take part in the blockchain. Receiving messages is more complicated,
    due to the fact that they depend more on other agents. A message first needs to be confirmed as still valid. As such the timestamp
    of the message is first compared to the blockchain. If the message is found to be outdated it is deleted. Since the agent cannot 
    control the rate at which messages come in, these messages are placed in a cue until the agent is ready to process them. Processing
    the message in what constitutes the trust base of the blockchain. The agent analyses the content of the message and compares it to 
    their local copy of the block chain. At this point the agent will check every transaction it knows took place and calculate wether
    enough funds are available fo the transaction to be valid. If that is true then the message is marked as true, else it is considered
    fraudulent. Transactions will also usually be received from two sources: the sender and the receiver. As such higher order knowledge
    is used again to check that the message from both sources matches as well as to ensure the same transaction isn't processed twice.
    <br>
    <br>
    <b>The Block</b> calss is as the name suggests the building block of the blockchain. A block represents essentially any transaction or
    message that gets added to the blockchain. It is the elementary storage unit for data in our system and ultimately has the role of 
    recording and storing any actions taking place in the system. The block has the ability to store data about a pareticular message or
    transaction, and to that end it contains a data field for storing the actual content of what it is registering, as well as fields for
    recording the agents involved, under the names of <i>sender</i> and <i>receiver</i>. These blocks will additionally  need to eventually 
    be linked up into the blockchain, and in order to acomplish this two more features are required. Firstlly, each block is numbered, this 
    allows the system to keep track of the order of transactions and events, the numbering of these blocks monotonously increases, with the
    first block in the blockchain being block 0. Secondly, each block has a unique hash value. This hash value expresses the identity of the
    block and is made up using data from all other parameter of the current block plus the hash of the previous block (which ensures traceability).
    Also related to the block class is another class the <b>pendingBlock</b>. This pendingBlock class essentially acts as an intermediary
    being used to store, as the name implies, pending blocks either from the memeory of various agents or in queue to be added to the blockchain.
    The pendingBlock class is similar to Block in the type of information it stores only it dosen't have a hash or number field, instead being
    identified through a simple ID. Additionally the pendingBlock class also has a few extra features that facilitate checking and validating.
    <br>
    <br>
    <b>The BlockChain</b> calss is perhaps the most important class in our implementation, tying everything toghether and implementing the
    very backbone of our model. The BlockChain class doubles as not only implementing the blockchain itself but also acting as a sort of
    run function for our simulation, setting everything into motion. The BlockChain we use is essentially a series of blocks, with several 
    methods which ensure that all the blocks being added are valid and in the correct order. Our BlockChain also additionally keeps track of
    agents (this is more related to it's secondary function than necessarily an actual blockchain) and has a queue of pending blocks that are
    to be checked and added.
    <br>
    <br>
    First we will talk about the BlockChain class as it relates to the functioning as structure of actual blockchains. At the very root of
    the BlockChain is what is known a a genesis block, which has 0 in all fields. Every blockchain has such a block and it represents the
    starting point of the chain.  From here new blocks are added to the cahin, if they are valid of course, a sabity check is also performed
    at this stage. We implemented a treshold of 5 for the checks performed before adding or removing a block. That is to say if 5 different 
    agents agree that a certain block  is correct the respective block will be aproved and added to th blockchain. Conversely, if 5 agents
    agree that a block is fraudulent said block is deleted. This relatively low threshold provides slightly less protection than real life 
    blockchains however it also greatly increases performance, and as there is no way for the agent that initiates the transaction to know
    which agents will be veryfiyng it first (and therefore that it needs to manipulate) this is still a resonably safe method. Finally, at
    every timestep the validity of the blockchain is verified, block hashes are inspected and validated. 
    <br>
    <br>
    Second we will talk about the BlockChain class as it relates to the implementation and running of our simulation. As discussed previously, rather
    than model our simulation of a blockchain using multiple asynchronous threads representing each agent we have decided that for the purposes
    of analysing the manner in which a blockchain functions form the point of view of epistemic logic, as well as to increase performance,
    we would implement a model running a number of transactions from various agents in a single thread. This thread is implemented within 
    the BlockChain class. First of all the setup: our simulation considers 100 agents each with 1000 coins. The creation of these agents 
    also constitutes the first blocks added to the blockchain after the genesis block, unlike blocks initiated by agents these initial 
    blocks do not need to be verified as we are sure they are valid. Then the actual simulation is implemented as a stochastic process. First,
    at every time step two different random agents are selected, these agents will begin a transaction. A transaction however will not always
    be succesful or truthfull. For every transaction there is a chance that either the transaction will be invalid or that the sneder and
    receiver will disagree about it's contents, these represent fraudulent messages which will be idetified as such. There is also a chance
    that a message will fail for unkown reasons, this is to essentially model the inherent risk in any communication method. After messages related to all transactions that take place during a timestep have been sent out, they are 
    analysed and processsed. First the actual sending out of the messages happens, where these messages are sent to other agents. These messages
    are then place in a queue individual for each agent. Agents go through their respective queues and analyse the messages in them, either
    validating or invalidating them. All valid messages are formed into blocks and added to the blockchain, then agents are updated with 
    respect to this change of the blockchain. Finally the blockchain checks that it's integrity has not been compromissed and the whole process
    repeats in the following timestep.


</p>

<h2 style="text-align:center">Conclusions and discussion</h2>

<br>
<br>
<p style="width: 500px;" align="justify" style="text-align:justify">

Overall the blockchain met our expectations and performed correctly. We ran a simulation consisting of 10 timesteps. 
The following parameters were used: a 10% chance for a message to be invalid due to an agent using more funds then they have,
a 10% chance for the data to be invalid due to there being different messages from the sender and receiver, and a 30% chance that 
sending a message will fail fo message transmission related reasons. Over the course of our simulations we not only saw messages added
sucessfully but also blocks rejected by agents on the basis of them being found to be fraudulent. In short the blockchain model works, both
as a ledger for transactions and as an arbiter ensuring that transactions are valid and fair. 
<br>
<br>
As previously mentioned cryptocurrencies in general, and the blockchain in particular are very interesting real world cutting edge applications
of concepts  found in epistemic logic. A blockchain can be thought essentially as a system of accountability based on employing a group of
perfect logicians. Everytime someone does anything they must make a public announcement, sharing the knowledge of what thay have done with
everyone. These perfect logicians then use their knowledge of preexisting facts in order to decide wether that action is possible. Should 
there be contradictions the action is determined to be a lie. All of these preesxisting facts then form a common knowledge shared between
all truthful agents, essentially the blockchain. This type of application of logic has allowed a big change in the dynamics of economic 
systems across the planet. By using this new system it is now possible to create a currency system that is completly decentralised, removed
from any sort of central governing authority and that therefore does not require the trust of its users be placed into a single ideological, 
political or economic body. Indeed it rather requires trusting that everyone else is mainly interesting in only serving their own interests,
yet through the implementation of this, ultimately robust and not overly complicated logic system of checking public announcements against
a pool of common knowledge these interests are able to be used to guarantee equitability and a trustworthy system for all.

</p>
</center>
</body>

</html>
